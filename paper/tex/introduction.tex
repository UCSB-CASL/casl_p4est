%!TEX root = draft.tex
\section{Introduction}
\begin{enumerate}
\item \textbf{What is level-set and why is it important?}
The level-set method, originally proposed by Sethian and Osher \fcite{classic LS paper}, is a popular and powerful framework for tracking arbitrary interfaces that undergo complicated topological changes. As a result, the level-set method has wide range of application such as multiphase flows, moving boundary problems, image segmentation, and computer graphics graphics, to only name a few \fcite{fedkiw/osher's book, sethian's book}.

\item \textbf{What are the main issues of using level-set method?}
What makes level-set method powerful and easy to use is that in this method location of the interface is defined implicitly on an underlying grid. This convenience, however, comes at a price. First, compared to an explicit method, e.g. front tracking \fcite{front tracking refs}, level-set method is typically less accurate and mass conservation could be a problem although progress has been made in resolving this issue \fcite{Enright/Fedkiw paper, other?}. Second, the level-set function has to be defined in a higher dimensional space compared to the interface. If only the location of interface is needed, the added dimension greatly increases the overall computational cost. This problem, however, could be handled by computing the level-set only close to the interface, e.g. as in the narrow-band level-set method \fcite{narrow band, the hash table paper?}.

\item \textbf{Why using AMR helps? How do we plan to extend that paper here?}
Another approach that can address both problems is the use of local grid refinement. In \fcite{Frederic paper}, authors present second-order accurate level-set methods on Cartesian Quadtree (two dimensions) and Octree (three dimensions) grids. Use of tree-based Cartesian adaptive grids in the context of level-set method is quite advantageous because 1) It gives fine-grain control over error, which typically occurs close to the interface, 2) It can effectively reduce the dimensionality of the problem by focusing most of the cells close to the interface, and 3) Construction and handling of the tree is quite simple in the presence of an interface which defines a an ideal metric for refinement. Although use of adaptive grids dramatically reduces the computational time, performing high-resolution three dimensional calculations of complex interfacial problems, e.g. crystal growth in binary alloys \fcite{Maxime's paper}, is still challenging. In this paper we extend these algorithms by proposing parallel implementations on distributed memory machines using domain decomposition technique and Message Passing Interface (MPI) library.

\item \textbf{What is the main challenge for parallelization?}
One of the main challenges in parallelizing level-set algorithms on adaptive grids, is handling the grid itself in parallel. One option is to replicate the entire grid on each processor and use off-the-self graph partitioners, e.g. Metis or ParMetis \fcite{metis/parmetis paper}, for load balancing and domain decomposition \fcite{origial deal.II paper}. This approach, however, is only scalable to a few hundred processor at best and is limited by the size of the grid itself. Moreover, use of a general-purpose graph partitioner adds extra overhead that limits the overall scalability even further. Interestingly, Quadtrees and Octrees have nice spatial ordering that naturally lead to the concept of Space Filling Curves (SFC) \fcite{SFC reference} which can be efficiently exploited for high quality load balancing.

\item \textbf{Parallel octrees: p4est, dendro, octor, etc. How do we plan to use p4est?}
The idea of using SFCs for parallel partitioning of Quad-/Octrees is not new in itself. In \fcite{octor} authors first used the idea of using Morton curve (also known as Z-curve) for traversing the leaves of an Octree which is then used to index and distribute them between processors. Dendro \fcite{dendro paper} follows similar ideas for developing a parallel geometric multigrid on balanced octrees. More recently, authors in \fcite{p4est} extended these ideas to a collection, or a ``forest'', of octrees that are connected through a common, potentially unstructured, hexahedral grid. They then use a global Morton curve to partition the entire forest in parallel. Implementation of these algorithms, which were shown to scale to more than 200,000 processors, are publicly available through simple API provided by the \texttt{p4est} library \fcite{p4est website?}. In fact the algorithms presented in this paper are directly implemented on top of \texttt{p4est} library and we do not discuss any algorithm that is already covered by \texttt{p4est} implementation. Instead make appropriate references to \fcite{p4st paper} whenever necessary.

\item \textbf{Parallel reinitialization methods? What are the challenges? Whats out there?}

\item \textbf{Parallel semi-lagrangian methods? What are the challenges? Whats out there?}

\item \textbf{Whats the organization of the paper}
\end{enumerate}