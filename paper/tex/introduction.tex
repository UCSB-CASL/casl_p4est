%!TEX root = draft.tex
\section{Introduction}
The level-set method, originally proposed by Sethian and Osher \cite{Osher;Sethian:88:Fronts-Propagating-w}, is a popular and powerful framework for tracking arbitrary interfaces that undergo complicated topological changes. As a result, the level-set method has wide range of application such as multiphase flows, moving boundary problems, image segmentation, and computer graphics graphics \cite{Osher;Fedkiw:01:Level-Set-Methods:-A,Sethian:99:Level-set-methods-an}. An important feature which makes this method powerful and easy to use is that the location of interface is defined implicitly on an underlying grid. This convenience, however, comes at a price. First, compared to an explicit method, e.g. front tracking \cite{Juric:96:A-Front-Tracking-Met, Tryggvason;Bunner;Esmaeeli;etal:01:A-Front-Tracking-Met}, level-set method is typically less accurate and mass conservation could be a problem; although progress has been made in resolving this issue \cite{Enright;Fedkiw;Ferziger;etal:02:A-Hybrid-Particle-Le}. Second, the level-set function has to be defined in a higher dimensional space compared to the interface. If only the location of interface is needed, the added dimension greatly increases the overall computational cost. One way to avoid this problem is by computing the level-set only close to the interface, e.g. as in the narrow-band level-set method \cite{Adalsteinsson;Sethian:95:A-Fast-Level-Set-Met} or, more recently, by using a hash table to restrict both computation and storage requirements \cite{Brun;Guittet;Gibou:12:A-local-level-set-me}.

Another approach that can address both problems is the use of local grid refinement. In \cite{Strain:99:Tree-Methods-for-Mov} the idea of using tree-based grids for level-set calculations was first introduced and later extended in \cite{Losasso;Gibou;Fedkiw:04:Simulating-Water-and} for graphics application. More recently, authors in \cite{Min;Gibou:07:A-second-order-accur} proposed second-order accurate level-set methods on Quadtree (two dimensions) and Octree (three dimensions) grids. Use of tree-based adaptive grids in the context of level-set method is quite advantageous because: 1) It gives fine-grain control over error, which typically occurs close to the interface and 2) It can effectively reduce the dimensionality of the problem by focusing most of the grid cells close to the interface. Fortunately, construction of the tree is quite simple in the presence of an interface that naturally defines an ideal metric for refinement. Although use of adaptive grids can dramatically reduce the computational cost, performing high-resolution three dimensional calculations of complex interfacial problems, e.g. crystal growth in binary alloys \cite{Theillard;Gibou;Pollock:14:A-Sharp-Computationa}, could take a very long time in serial. In this paper we extend these algorithms by proposing parallel algorithms for distributed memory machines using domain decomposition technique.

One of the main challenges in parallelizing level-set algorithms on adaptive grids is handling the grid itself. One option is to replicate the entire grid on each processor and use off-the-shelf graph partitioners, e.g. ParMetis \cite{Karypis;Kumar:98:A-parallel-algorithm} or Zoltan \cite{Boman;Catalyurek;Chevalier;etal:12:The-Zoltan-and-Isorr}, for load balancing and domain decomposition. For instance, this was the approach originally taken by the \texttt{deal.II} library \cite{Bangerth;Hartmann;Kanschat:07:deal.II----a-General}. This approach, however, is only scalable to a few hundred processor at best and is limited by the size of the grid itself. Moreover, use of a general-purpose graph partitioner adds extra overhead that can limit the overall scalability even further. Interestingly, tree-based grids have nice spatial ordering that naturally lead to the concept of space-filling curves (SFCs) which can be efficiently exploited for parallel load balancing \cite{Aluru;Sevilgen:97:Parallel-domain-deco,Campbell;Devine;Flaherty;etal:03:Dynamic-octree-load-}.

The idea of using SFCs for parallel partitioning of Quad-/Octrees is not new in itself and has been tried by many researchers. For instance, \texttt{Octor} \cite{Tu;OHallaron;Ghattas:05:Scalable-parallel-oc} uses a Morton curve (also known as Z-curve) for traversing the leaves of an Octree for indexing and load balancing and has been scaled up to 62,000 cores \cite{Burstedde;Ghattas;Gurnis;etal:08:Scalable-adaptive-ma}. \texttt{Dendro} \cite{Sampath;Adavani;Sundar;etal:08:Dendro:-parallel-alg} is another example of an octree code in which similar ideas are used for parallel partitioning and development of a parallel geometric multigrid that has been scaled up to about 32,000 cores \cite{Sampath;Biros:10:A-parallel-geometric}. More recently, authors in \cite{Burstedde;Wilcox;Ghattas:11:p4est:-Scalable-Algo} extended these ideas to a collection, or a ``forest'', of octrees that are connected through a common, potentially unstructured, hexahedral grid. This forest is then partitioned in parallel using a global Morton curve. Implementation of these algorithms, which were shown to scale to more than 200,000 processors, are publicly available through simple API provided by the \texttt{p4est} library \cite{p4est-github}. In fact the algorithms presented in this paper are directly implemented on top of \texttt{p4est} library and we do not discuss any algorithm that is already covered in \cite{Burstedde;Wilcox;Ghattas:11:p4est:-Scalable-Algo}. We also make use of the popular \texttt{PETSc} \cite{Balay;Abhyankar;Adams;etal:14:PETSc-Web-page} library for linear algebra and its parallel primitives, such as parallel ghosted vector and scatter/gather operations, which simplifies the implementation. 

Parallel level-set algorithms can be categorized in two groups: 1) Parallel advection algorithms and 2) Parallel reinitialization algorithms. Eulerian advection schemes can easily be parallelized but unfortunately are limited by the CFL condition which could be very restrictive for adaptive grids. Semi-Lagrangian methods combine the unconditional stability of Lagrangian methods and the ease of use of Eulerian grids and have been successfully used for advecting the level-set function on tree-based grids before \cite{Min;Gibou:07:A-second-order-accur}. However, parallelizing the semi-Lagrangian algorithm in a domain decomposition context is not an easy task. The reason for this is twofold: First, depending on the CFL number, the departure points may end up outside the ghost region and in remote processors that are potentially far away. This requires a very dynamic and nonuniform communication pattern which is complicated to implement. For adaptive grids situation is even more complicated due to the asymmetric nature of communication (c.f. \ref{section::parallel algorithms}). Second, load balancing could be an issue for large CFL numbers and nonuniform velocity fields due to clustering of departure points and can considerably restrict the scalability of the algorithm. Both of these problems, of course, could be avoided by choosing $\text{CFL} \le 1$ but that would defeat the purpose of using semi-Lagrangian algorithm in the first place. 

Nonetheless, several parallel semi-Lagrangian algorithms have been proposed in the past. A simple domain decomposition technique was used in \cite{Thomas;Cote:95:Massively-parallel-s} where the width of ghost layer is fixed based on the maximum CFL number to ensure all departure points are covered by the ghost layer. At large CFL numbers, this leads to large communication volume that can limit the scalability. Nonetheless good scaling was report for small CFL numbers ($\text{CFL} \le 2$). In \cite{Drake;Foster;Michalakes;etal:95:Design-and-performan} authors propose a more sophisticated domain decomposition approach which uses a ``dynamic ghost layer''. Here the width of the ghost layer is dynamically determined at runtime based on information from previous time steps. Unfortunately, however, this approach seems to suffer from excessive communication overhead at larger number of processors as well. More recently, authors in \cite{White-III;Dongarra:11:High-performance-hig} used a domain decomposition strategy on a cubed sphere but with a single layer of ghost nodes. Interpolation on remote processors is then handled by sending query points to the corresponding processor and asking for the interpolated result. This approach seems to provide good scalability for transporting a single tracer up to about 1000 cores for $\text{CFL} \sim 10$. At higher CFL numbers the method begins to loose scalability due to an increase in communication volume. Although in this article we are mainly interested in parallel semi-Lagrangian methods, one could resort to finite difference or finite element discretization methods if small CFL numbers are acceptable. Indeed several algorithms of this type has been proposed with applications in modeling dendritic crystal growth \cite{Wang;Chang;Kale;etal:06:Parallelization-of-a}, multiphase flows \cite{Sussman:05:A-parallelized-adapt, Fortmeier;Bucker:11:A-parallel-strategy-, Rodriguez;Sahni;Lahey-Jr;etal:13:A-parallel-adaptive-}, and atomization process \cite{Herrmann:10:A-parallel-Eulerian-}.
%, and image segmentation on GPUs \cite{Lefohn;Cates;Whitaker:03:Interactive-GPU-base,Cates;Lefohn;Whitaker:04:GIST:-an-interactive,Roberts;Packer;Sousa;etal:10:A-work-efficient-GPU}.

In many applications of the level-set method, it is desirable for the level-set function to be a signed distance function, i.e. $|\nabla \phi| = 1$. There are generally two approaches to enforce this property: 1) Solving the pseudo-time transient reinitialization equation \cite{Sussman;Smereka;Osher:94:A-Level-Set-Approach, Osher;Fedkiw:01:Level-Set-Methods:-A}:
\ben
\phi_\tau + S(\phi_0)\left(|\nabla \phi| - 1\right) = 0,
\een
or 2) Solving the Eikonal equation:
\ben
F(x)|\nabla\phi| = 1,
\een 
with constant speed function $F(x) \equiv 1$. The transient reinitialization equation can be solved using explicit finite differences and thus can easily be parallelized in a domain decomposition approach. Moreover, only a few iterations may be needed if the signed-distance property is only required close to the interface \cite{Min;Gibou:07:A-second-order-accur}. This is the approach we have chosen in this paper. If, however, the signed-distance property is required in the entire domain solving the Eikonal equation is more computationally efficient. Unfortunately, however, the most popular algorithm for solving the Eikonal equation, i.e. the Fast Marching Method \cite{Sethian:96:A-Fast-Marching-Leve,Sethian:99:Level-set-methods-an}, is inherently sequential due to causal relationship between grid points and cannot be easily parallelized. The Fast Sweeping Method (FSM) \cite{Zhao:05:A-fast-sweeping-meth} is an alternative method for solving the Eikonal equation iteratively. The FSM can be more computationally efficient for simple choices of speed function, e.g. as in this context, and for simple interfaces. Moreover, FSM has more potential for parallelization compared to the FMM.

One of the earliest attempt in parallelizing the FMM is reported in \cite{Herrmann:03:A-domain-decompositi} where a domain decomposition algorithm was introduced. Unlike the serial FMM, however, parallel FMM potentially requires multiple iteration or ``rollback operations'' to enforce the causality across processors. Similar ideas are described in details in \cite{Tugurlan:08:Fast-marching-method}. It should be noted that number of iterations for the parallel FMM to converge greatly depends on the complexity of the interface and also the parallel partitioning and, in general, fewer iterations are required if domains are aligned with the normals to the interface. Due to the nature of Eikonal equation, shared memory machines might be a better environment for parallelization. For instance, in \cite{Breus;Cristiani;Gwosdek;etal:11:An-adaptive-domain-d} authors use an ``adaptive'' technique where individual threads implicitly define a domain decomposition at runtime. Unfortunately, however, this approach does not seem to be more effective than a simple static decomposition. In \cite{Zhao:07:Parallel-implementat} a parallel FSM method was presented for the fist time. However, a more scalable FSM was more recently proposed in \cite{Detrixhe;Gibou;Min:13:A-parallel-fast-swee} where the Cuthill-McKee numbering was utilize to expose more parallelism. More recently a two-scale, hybrid FMM-FSM was presented in \cite{Chacon;Vladimirsky:13:A-parallel-Heap-Cell} which, albeit being more complicated to implement, promises even better scalability. Finally, a parallel Fast Iterative Method (FIM) was proposed in \cite{Jeong;Whitaker:08:A-fast-iterative-met}. The FIM is similar to FMM in that it also maintains a list of ``active nodes''. Unlike FMM, however, FIM avoids sorting the list and allows for concurrent updating of all nodes in an iterative fashion.

The rest of this article is organized as follows: In section \ref{section::levelset method} we briefly review the sequential algorithms and discretization methods for the level-set equation on adaptive tree-based grids. These ideas are then extended in section \ref{section::parallel algorithms} to parallel using a domain decomposition method. In section \ref{section::scaling results} we provide several examples that illustrate the scalability of our algorithms. Finally, we close by providing an important application of our algorithms in modeling the solidification process by solving a Stefan problem in \ref{section::applications}.
