%!TEX root = draft.tex
\section{Introduction}
\begin{enumerate}
\item \textbf{What is level-set and why is it important?}
The level-set method, originally proposed by Sethian and Osher \fcite{classic LS paper}, is a popular and powerful framework for tracking arbitrary interfaces that undergo complicated topological changes. As a result, the level-set method has wide range of application such as multiphase flows, moving boundary problems, image segmentation, and computer graphics graphics, to only name a few \fcite{fedkiw/osher's book, sethian's book}.

\item \textbf{What are the main issues of using level-set method?}
What makes level-set method powerful and easy to use is that in this method location of the interface is defined implicitly on an underlying grid. This convenience, however, comes at a price. First, compared to an explicit method, e.g. front tracking \fcite{front tracking refs}, level-set method is typically less accurate and mass conservation could be a problem although progress has been made in resolving this issue \fcite{Enright/Fedkiw paper, other?}. Second, the level-set function has to be defined in a higher dimensional space compared to the interface. If only the location of interface is needed, the added dimension greatly increases the overall computational cost. This problem, however, could be handled by computing the level-set only close to the interface, e.g. as in the narrow-band level-set method \fcite{narrow band, the hash table paper?}.

\item \textbf{Why using AMR helps? How do we plan to extend that paper here?}
Another approach that can address both problems is the use of local grid refinement. In \fcite{Frederic paper}, authors present second-order accurate level-set methods on Cartesian Quadtree (two dimensions) and Octree (three dimensions) grids. Use of tree-based Cartesian adaptive grids in the context of level-set method is quite advantageous because 1) It gives fine-grain control over error, which typically occurs close to the interface, 2) It can effectively reduce the dimensionality of the problem by focusing most of the cells close to the interface, and 3) Construction and handling of the tree is quite simple in the presence of an interface which defines a an ideal metric for refinement. Although use of adaptive grids dramatically reduces the computational time, performing high-resolution three dimensional calculations of complex interfacial problems, e.g. crystal growth in binary alloys \fcite{Maxime's paper}, is still challenging. In this paper we extend these algorithms by proposing parallel implementations on distributed memory machines using domain decomposition technique and Message Passing Interface (MPI) library.

\item \textbf{What is the main challenge for parallelization?}
One of the main challenges in parallelizing level-set algorithms on adaptive grids, is handling the grid itself in parallel. One option is to replicate the entire grid on each processor and use off-the-self graph partitioners, e.g. Metis or ParMetis \fcite{metis/parmetis paper} or Zoltan \fcite{zoltan paper}, for load balancing and domain decomposition \fcite{origial deal.II paper}. This approach, however, is only scalable to a few hundred processor at best and is limited by the size of the grid itself. Moreover, use of a general-purpose graph partitioner adds extra overhead that limits the overall scalability even further. Interestingly, Quadtrees and Octrees have nice spatial ordering that naturally lead to the concept of Space Filling Curves (SFC) \fcite{SFC reference} which can be efficiently exploited for high quality load balancing.

\item \textbf{Parallel octrees: p4est, dendro, octor, etc. How do we plan to use p4est?}
The idea of using SFCs for parallel partitioning of Quad-/Octrees is not new in itself and has been tried by many researchers. For instance, Octor \fcite{octor} uses a Morton curve (also known as Z-curve) for traversing the leaves of an Octree which is then used to index and distribute them between processors and has been shown to scale up to 6200 cores \fcite{mantle convection octor}. Dendro \fcite{original dendro paper} is another example of parallel octree code in which similar ideas are used for parallel partitioning and development of a parallel geometric multigrid that has been scaled up to about 32000 cores \fcite{dendro parallel multigrid}. More recently, authors in \fcite{p4est} extended these ideas to a collection, or a ``forest'', of octrees that are connected through a common, potentially unstructured, hexahedral grid. They then use a global Morton curve to partition the entire forest in parallel. Implementation of these algorithms, which were shown to scale to more than 200,000 processors, are publicly available through simple API provided by the \texttt{p4est} library \fcite{p4est website?}. In fact the algorithms presented in this paper are directly implemented on top of \texttt{p4est} library and we do not discuss any algorithm that is already covered in \texttt{p4est paper}. Instead we focus on parallelization of level-set method on Quad-/Octrees and make appropriate references to \fcite{p4st paper} whenever necessary.

\item \textbf{Parallel semi-lagrangian methods? What are the challenges? Whats out there?}
Parallel level-set algorithms can be categorized in three separate groups: 1) Parallel advection algorithms, 2) Parallel reinitialization algorithms, and 3) Parallel motion under curvature algorithms. In this article we focus on developing algorithms for the first two categories. We also make use of the popular \texttt{PETSc} \fcite{petsc} library for solution of the linear systems that arise from the third category. Moreover, \texttt{PETSc} provides primitives, such as parallel ghosted vector and scatter/gather operations, which simplifies the implementation. 

Eulerian advection schemes can easily be parallelized but unfortunately are limited by the CFL condition. For adaptive grids, this could be very restrictive as the tree could be locally refined very deeply to capture quantities of interest. Semi-Lagrangian methods combine the unconditional stability of Lagrangian methods and the ease of use of Eulerian grids and have been successfully used for advecting the level-set function on Quad-/Octree grids before \fcite{Frederic's paper}. However, parallelizing the Semi-Lagrangian algorithm in a domain decomposition context is not an easy task. The reason for this is twofold: First, depending on the CFL number, the departure points may end up outside the ghost region and in remote processors that are potentially far away. This requires a very dynamic and nonuniform communication pattern which is complicated to implement. For adaptive grids situation is even more complicated due to the asymmetric nature of communication, i.e. every processor knows the message destination but no processor knows which processor to expect message from and how many. Second, depending on the CFL number, the distribution of departure points could be entirely independent of the original parallel partitioning. As a result large CFL numbers could result in very load-unbalanced distribution of departure points which restricts the scalability of the algorithm. Both of these problems, of course, could be avoided by choosing $\text{CFL} \le 1$ but that would defeat the purpose of using Semi-Lagrangian algorithm in the first place. 

\item \textbf{Parallel reinitialization methods? What are the challenges? Whats out there?}

\item \textbf{Whats the organization of the paper}
\end{enumerate}