#include "voronoi3D_new.h"
#include <vector>
#include <algorithm>

void Voronoi3D_NEW::clear()
{
  points.resize(0);
}

void Voronoi3D_NEW::get_Points( const vector<Voronoi3D_NEWPoint>*& points) const
{
  points = &this->points;
}

void Voronoi3D_NEW::push( int n, double x, double y,double z )
{
  for(unsigned int m=0; m<partitions.size(); m++)
  {
    if(partitions[m].n == n)
    {
      return;
    }
  }

  candidate_t c;
  c.n = n;
  c.p.x=x; c.p.y=y; c.p.z=z;
  partitions.push_back(c);
  init_polygon(partitions.size()-1);

  for(unsigned int i=0; i<partitions.size()-1; ++i)
  {
    /* if partition i was deleted, then no need to cut the new one by i and i needs to be adjusted */
    if(cut_polygon(i, partitions.size()-1))
      i--;
    /* if i was deleted, no more modifications to bring to other partitions */
    else if(cut_polygon(partitions.size()-1, i))
      break;
  }
}

void Voronoi3D_NEW::push( int n, Point3 &pt )
{
  push(n, pt.x, pt.y, pt.z);
}

void Voronoi3D_NEW::set_Center_Point( int nc, Point3 &pc )
{
  set_Center_Point(nc, pc.x, pc.y, pc.z);
}

void Voronoi3D_NEW::set_Center_Point( int nc, double x, double y, double z)
{
  this->nc = nc;
  pc.x = x;
  pc.y = y;
  pc.z = z;

  partitions.clear();
  points.clear();

  push(WALL_m00, pc.x-2*(pc.x-xmin), pc.y, pc.z);
  push(WALL_p00, pc.x+2*(xmax-pc.x), pc.y, pc.z);
  push(WALL_0m0, pc.x, pc.y-2*(pc.y-ymin), pc.z);
  push(WALL_0p0, pc.x, pc.y+2*(ymax-pc.y), pc.z);
  push(WALL_00m, pc.x, pc.y, pc.z-2*(pc.z-zmin));
  push(WALL_00p, pc.x, pc.y, pc.z+2*(zmax-pc.z));
}



void Voronoi3D_NEW::init_polygon(int n)
{
  Point3 norm((partitions[n].p - pc).normalize());
  Point3 pcn = (partitions[n].p+pc)*.5;

  Point3 rd(rand(), rand(), rand());
  rd /= rd.norm_L2();

  Point3& u = partitions[n].u;
  Point3& v = partitions[n].v;

  u = rd - norm*(rd.dot(norm));
  u /= u.norm_L2();

  v = u.cross(norm);
  if(v.norm_L2()<EPS)
    throw std::invalid_argument("Voronoi3D->init_polygon: wrong basis ...");

  v /= v.norm_L2();

  partitions[n].polygon.push_back(pcn + ( u+v)*big);
  partitions[n].polygon.push_back(pcn + (-u+v)*big);
  partitions[n].polygon.push_back(pcn + (-u-v)*big);
  partitions[n].polygon.push_back(pcn + ( u-v)*big);
}


/* cut polygon n by plane generated by point l */
bool Voronoi3D_NEW::cut_polygon(int n, int l)
{
//  if(n==11 && l==4)
//  {
//    std::cout << "cutting " << n << " by " << l << std::endl;
//    std::cout << partitions[l].p << partitions[n].p << pc;
//  }
  Point3 pcl = (partitions[l].p + pc)*.5;

  Point3 &u = partitions[l].u;
  Point3 &v = partitions[l].v;

  /* 0 - keep
   * 1 - new
   * 2 - delete
   */
  std::vector<int> status(partitions[n].polygon.size(), 0);

  if(0 && n==4 && l==7)
  {
    std::cout << "before cutting by " << l << std::endl;
    for(int i=0; (unsigned int) i<partitions[n].polygon.size(); ++i)
      std::cout << partitions[n].polygon[i];
    std::cout << std::endl;
  }

  for(int i=0; (unsigned int) i<partitions[n].polygon.size(); ++i)
  {
    int k = mod(i-1, partitions[n].polygon.size());
//    std::cout << "dealing with point " << i << ", neighbor is " << k << std::endl;

    Point3 &pk = partitions[n].polygon[k];
    Point3 &pi = partitions[n].polygon[i];
    Point3 pik = pk - pi;
//    if(n==3 && l==6) std::cout << "Point " << pi << std::endl;

    /* compute the intersection with the plane */
    Point3 pcli = pi - pcl;

    double det = u.x*v.y*pik.z + u.y*v.z*pik.x + u.z*v.x*pik.y - u.x*v.z*pik.y - u.y*v.x*pik.z - u.z*v.y*pik.x;

    if(fabs(det)>EPS)
    {
      double alpha = ( (u.z*v.y-u.y*v.z)*pcli.x + (u.x*v.z-u.z*v.x)*pcli.y + (u.y*v.x-u.x*v.y)*pcli.z ) / det;

      if(0 && n==4 && l==7) std::cout << "here # " << i << std::endl;
      if(alpha>-EPS && alpha<1+EPS)
      {
//        if(n==4 && l==7) std::cout << "cuting  " << alpha << std::endl;
//        double a = ( (v.y*pik.z-v.z*pik.y)*pcli.x + (v.z*pik.x-v.x*pik.z)*pcli.y + (v.x*pik.y-v.y*pik.x)*pcli.z ) / det;
//        double b = ( (u.z*pik.y-u.y*pik.z)*pcli.x + (u.x*pik.z-u.z*pik.x)*pcli.y + (u.y*pik.x-u.x*pik.y)*pcli.z ) / det;

        Point3 p_new = pi + pik*alpha;
//        if(ABS(p_new.x)<EPS) p_new.x = 0;
//        if(ABS(p_new.y)<EPS) p_new.y = 0;
//        if(ABS(p_new.z)<EPS) p_new.z = 0;
//        if(n==3 && l==6) std::cout << "intersect # " << p_new << std::endl;

        if((p_new-partitions[n].polygon[k]).norm_L2()>EPS && (p_new-partitions[n].polygon[i]).norm_L2()>EPS)
        {
          if((pcl-pc).dot(pik.normalize()) > 0)
            status[k] = 2;
          else
            status[i] = 2;

          partitions[n].polygon.insert(partitions[n].polygon.begin()+i, p_new);
          status.insert(status.begin()+i, 1);

          i++;
        }
        else if((p_new-partitions[n].polygon[i]).norm_L2()<EPS && (pcl-pc).dot(pik.normalize()) > 0)
        {
          status[i] = 1;
          status[k] = 2;
        }
        else if((p_new-partitions[n].polygon[k]).norm_L2()<EPS && (pcl-pc).dot(pik.normalize()) < 0)
        {
          status[i] = 2;
          status[k] = 1;
        }
      }
    }
  }


  /* if there was no intersection at all, the polygon might need to be completely deleted */
  if(std::find(status.begin(), status.end(), 2)==status.end())
  {
    /* if the segment between any vertex of the polygon and pc crosses the plane l, then
     * the polygon must be deleted. Otherwise, plane l didn't influence this polygon
     */
    Point3 pc0;
    double det = 0;

    unsigned int i = 0;
    while(fabs(det)<EPS && i<partitions[n].polygon.size())
    {
      pc0 = partitions[n].polygon[i] - pc;
      det = u.x*v.y*pc0.z + u.y*v.z*pc0.x + u.z*v.x*pc0.y - u.x*v.z*pc0.y - u.y*v.x*pc0.z - u.z*v.y*pc0.x;
      i++;
    }

    if(i==partitions[n].polygon.size() && fabs(det)<EPS)
      throw std::invalid_argument("voronoi3D: could not cut the polygon with the plane.");

    Point3 pccl = pc-pcl;
    double alpha = ( (u.z*v.y-u.y*v.z)*pccl.x + (u.x*v.z-u.z*v.x)*pccl.y + (u.y*v.x-u.x*v.y)*pccl.z ) / det;
    if(alpha>EPS && alpha<1-EPS)
    {
//      std::cout << "erased " << n << std::endl;
      partitions.erase(partitions.begin()+n);
      return true;
    }
  }
  else
  {
    /* propagate delete information if many vertices in a row must be removed */
    bool trig = false;
    for(int j=0; (unsigned int) j<2*status.size(); ++j)
    {
      int i = j%status.size();
      int k = mod(i-1, status.size());

      if(trig && status[i]==0)
        status[i] = 2;
      else if(status[i]==2 && status[k]==1)
        trig = true;
      else if(status[i]==1 && status[k]==2)
        trig = false;
    }

    /* delete points */
    int cpt = 0;
    for(int i=0; (unsigned int) i<status.size(); ++i)
    {
      if(status[i]==2)
      {
        partitions[n].polygon.erase(partitions[n].polygon.begin()+i-cpt);
        cpt++;
      }
    }
  }

  return false;
}


void Voronoi3D_NEW::construct_Partition(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax,
                                    bool periodic_x, bool periodic_y, bool periodic_z)
{

}



void Voronoi3D_NEW::print_VTK_Format( const std::vector<Voronoi3D_NEW>& voro, const char* file_name )
{
  FILE* f;
  f = fopen(file_name, "w");
#ifdef CASL_THROWS
  if(f==NULL) throw std::invalid_argument("[CASL_ERROR]: Voronoi3D: cannot open file.");
#endif

  int nb_vertices = 0;
  int nb_polygons = 0;

  // first count the number of vertices and polygons
  for(unsigned int n=0; n<voro.size(); n++)
  {
    for(unsigned int nb=0; nb<voro[n].partitions.size(); ++nb)
    {
//      if(voro[n].partitions[nb].n < (int) n)
      {
        nb_polygons += 1;
        nb_vertices += voro[n].partitions[nb].polygon.size();
      }
    }
  }

  // add the vertices information to the VTK file
  fprintf(f, "# vtk DataFile Version 2.0\n");
  fprintf(f, "Voronoi partition\n");
  fprintf(f, "ASCII\n");
  fprintf(f, "DATASET POLYDATA\n");


  /* output the list of points */
  fprintf(f, "POINTS %d double\n", nb_vertices);
  for(unsigned int n=0; n<voro.size(); n++)
  {
    for(unsigned int nb=0; nb<voro[n].partitions.size(); ++nb)
    {
//      if(voro[n].partitions[nb].n < (int) n)
      {
        for(unsigned int k=0; k<voro[n].partitions[nb].polygon.size(); ++k)
          fprintf(f, "%e %e %e\n", voro[n].partitions[nb].polygon[k].x, voro[n].partitions[nb].polygon[k].y, voro[n].partitions[nb].polygon[k].z);
      }
    }
  }


  /* output the list of polygons */
  fprintf(f, "POLYGONS %d %d\n", nb_polygons, nb_vertices+nb_polygons);
  int cpt = 0;
  for(unsigned int n=0; n<voro.size(); n++)
  {
    for(unsigned int nb=0; nb<voro[n].partitions.size(); ++nb)
    {
//      if(voro[n].partitions[nb].n < (int) n)
      {
        fprintf(f, "%lu ", voro[n].partitions[nb].polygon.size());
        for(unsigned int k=0; k<voro[n].partitions[nb].polygon.size(); ++k)
        {
          fprintf(f, "%d ", cpt);
          cpt++;
        }
        fprintf(f, "\n");
      }
    }
  }

  fclose(f);

  printf("Saved voronoi partition in %s\n", file_name);
}
